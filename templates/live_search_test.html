<!DOCTYPE html>
<html>

<head>
  <title>Live Search Test</title>
  <style>
    body {
      font-family: sans-serif;
    }

    #videoContainer {
      position: relative;
      width: 640px;
      height: 480px;
      border: 1px solid black;
    }

    #video {
      display: block;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      /* Mirror view */
    }

    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      /* Allows clicks through */
    }

    #status {
      margin-top: 10px;
      font-weight: bold;
    }

    .match {
      color: green;
    }

    .no-match {
      color: red;
    }

    .other {
      color: orange;
    }

    .error {
      color: darkred;
      background-color: #fee;
      padding: 5px;
    }
  </style>
</head>

<body>
  <h1>Live Face Search Test</h1>
  <div>
    <button id="connectBtn">Connect & Start Camera</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
  </div>
  <div id="videoContainer">
    <video id="video" width="640" height="480" autoplay playsinline></video>
    <canvas id="overlayCanvas" width="640" height="480"></canvas> <!-- For drawing boxes -->
  </div>
  <canvas id="snapshotCanvas" width="640" height="480" style="display:none;"></canvas> <!-- For sending -->
  <div id="status">Status: Disconnected</div>
  <pre id="messages" style="max-height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 5px;"></pre>

  <script>
    const video = document.getElementById('video');
    const snapshotCanvas = document.getElementById('snapshotCanvas');
    const snapshotContext = snapshotCanvas.getContext('2d');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const overlayContext = overlayCanvas.getContext('2d');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const statusDiv = document.getElementById('status');
    const messagesDiv = document.getElementById('messages');

    let websocket = null;
    let stream = null;
    let intervalId = null;
    let animationFrameId = null;
    const frameInterval = 100; // ms - How often to send frames
    let lastMatchData = null; // Store last match to draw box

    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
        video.srcObject = stream;
        statusDiv.textContent = 'Status: Camera started. Ready to connect.';
        statusDiv.className = 'other';
        startDrawingLoop(); // Start drawing overlay
        return true;
      } catch (err) {
        console.error("Error accessing camera: ", err);
        statusDiv.textContent = `Status: ERROR starting camera - ${err.message}`;
        statusDiv.className = 'error';
        stopDrawingLoop();
        return false;
      }
    }

    function connectWebSocket() {
      if (websocket && websocket.readyState === WebSocket.OPEN) return;

      const wsUrl = `ws://${window.location.host}/api/v1/live-search/ws`;
      websocket = new WebSocket(wsUrl);
      statusDiv.textContent = `Status: Connecting to ${wsUrl}...`;
      statusDiv.className = 'other';
      messagesDiv.textContent = '';
      lastMatchData = null; // Reset last match on connect

      websocket.onopen = () => {
        console.log("WebSocket Connected");
        statusDiv.textContent = `Status: Connected. Sending frames...`;
        statusDiv.className = 'match';
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        startSendingFrames();
      };

      websocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log("Message from server: ", data);
          handleServerMessage(data); // Process message and update state
          logMessage(data);
        } catch (e) {
          console.error("Failed to parse message or invalid message format:", event.data, e);
          logMessage({ error: "Received invalid message", data: event.data });
          statusDiv.textContent = 'Status: Received invalid message from server.';
          statusDiv.className = 'error';
          lastMatchData = null; // Clear box on error
        }
      };

      websocket.onerror = (error) => {
        console.error("WebSocket Error: ", error);
        statusDiv.textContent = 'Status: WebSocket Error (check console)';
        statusDiv.className = 'error';
        logMessage({ error: "WebSocket Error", details: error });
        stopSendingFrames();
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        lastMatchData = null;
      };

      websocket.onclose = (event) => {
        console.log("WebSocket Disconnected:", event.reason, event.code);
        statusDiv.textContent = `Status: Disconnected - ${event.reason || 'Connection closed'} (Code: ${event.code})`;
        statusDiv.className = event.wasClean ? 'other' : 'error';
        logMessage({ event: "WebSocket Closed", code: event.code, reason: event.reason, wasClean: event.wasClean });
        stopSendingFrames();
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        websocket = null;
        lastMatchData = null;
      };
    }

    function disconnectWebSocket() {
      if (websocket) {
        websocket.close(1000, "User disconnected");
      }
      stopSendingFrames();
    }

    function startSendingFrames() {
      if (!stream || !websocket || websocket.readyState !== WebSocket.OPEN) return;
      if (intervalId) clearInterval(intervalId);

      intervalId = setInterval(() => {
        if (websocket && websocket.readyState === WebSocket.OPEN && video.readyState >= video.HAVE_CURRENT_DATA) {
          snapshotContext.drawImage(video, 0, 0, snapshotCanvas.width, snapshotCanvas.height);
          snapshotCanvas.toBlob((blob) => {
            if (blob && websocket && websocket.readyState === WebSocket.OPEN) {
              websocket.send(blob);
            }
          }, 'image/jpeg', 0.8);
        } else if (websocket && websocket.readyState !== WebSocket.OPEN) {
          stopSendingFrames();
        }
      }, frameInterval);
      console.log("Started sending frames interval.");
    }

    function stopSendingFrames() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
        console.log("Stopped sending frames interval.");
      }
    }

    function handleServerMessage(data) {
      let statusText = 'Status: ';
      let statusClass = 'other';
      lastMatchData = null; // Clear previous match data by default

      if (data.status === 'match_found' && data.match) {
        const match = data.match;
        statusText += `MATCH FOUND: ID=${match.face_id}, Name=${match.name || 'N/A'}, Sim=${match.similarity.toFixed(3)}`;
        statusClass = 'match';
        lastMatchData = data; // Store data with box info
      } else if (data.status === 'no_match_found') {
        statusText += 'No match found (Face detected)';
        statusClass = 'no-match';
        lastMatchData = data; // Store to draw box if available
      } else if (data.status === 'no_face_detected') {
        statusText += 'No face detected';
        statusClass = 'other';
      } else if (data.status === 'error') {
        statusText += `ERROR - ${data.message || 'Unknown processing error'}`;
        statusClass = 'error';
      } else {
        statusText += `Unknown status: ${data.status}`;
      }
      statusDiv.textContent = statusText;
      statusDiv.className = statusClass;
    }

    function startDrawingLoop() {
      if (animationFrameId) cancelAnimationFrame(animationFrameId); // Stop previous loop
      function drawLoop() {
        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); // Clear canvas
        if (lastMatchData && lastMatchData.detection_box) {
          drawBoundingBox(lastMatchData);
        }
        animationFrameId = requestAnimationFrame(drawLoop); // Continue loop
      }
      drawLoop(); // Start the loop
    }

    function stopDrawingLoop() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); // Clear canvas
      }
    }


    function drawBoundingBox(data) {
      const box = data.detection_box; // [x1, y1, x2, y2]
      if (!box || box.length !== 4) return;

      // --- IMPORTANT: Mirror coordinates ---
      // Because the video feed is mirrored (transform: scaleX(-1)),
      // we need to mirror the X coordinates for drawing.
      const canvasWidth = overlayCanvas.width;
      const x1 = canvasWidth - box[2]; // Mirrored x1 = width - original x2
      const y1 = box[1];
      const x2 = canvasWidth - box[0]; // Mirrored x2 = width - original x1
      const y2 = box[3];
      const width = x2 - x1;
      const height = y2 - y1;
      // --- End Mirroring ---

      let color = 'orange'; // Default for no_match or error with box
      let label = 'Unknown';

      if (data.status === 'match_found' && data.match) {
        color = 'lime'; // Bright green
        label = `${data.match.name || data.match.face_id} (${data.match.similarity.toFixed(2)})`;
      } else if (data.status === 'no_match_found') {
        color = 'red';
      }

      overlayContext.strokeStyle = color;
      overlayContext.lineWidth = 2;
      overlayContext.strokeRect(x1, y1, width, height);

      // Draw label background
      overlayContext.fillStyle = color;
      const text = label;
      const textMeasure = overlayContext.measureText(text);
      const textWidth = textMeasure.width;
      const textHeight = 14; // Approximate height
      overlayContext.fillRect(x1, y1 - textHeight - 2, textWidth + 4, textHeight + 2);

      // Draw label text
      overlayContext.fillStyle = 'black';
      overlayContext.font = '14px sans-serif';
      overlayContext.fillText(text, x1 + 2, y1 - 2);
    }

    function logMessage(data) {
      const time = new Date().toLocaleTimeString();
      messagesDiv.textContent += `${time}: ${JSON.stringify(data)}\n`;
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Initialization
    connectBtn.onclick = () => {
      startCamera().then(success => {
        if (success) connectWebSocket();
      });
    };
    disconnectBtn.onclick = disconnectWebSocket;

    // Stop drawing loop if page is hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopDrawingLoop();
      } else if (stream) { // Resume only if camera was active
        startDrawingLoop();
      }
    });

  </script>
</body>

</html>